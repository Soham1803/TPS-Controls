/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/player.glb -o src/app/components/Player.tsx 
*/

import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useKeyboardControls, PositionalAudio } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { CapsuleCollider, RapierRigidBody, RigidBody, useRapier } from '@react-three/rapier'
import RAPIER from '@dimforge/rapier3d-compat'

// Import modular functions and types
import type { GLTFResult, PlayerProps } from './modules/player/types'
import { useAnimationSetup } from './modules/player/useAnimationSetup'
import { handleMovement } from './modules/player/movement'
import { handleJump } from './modules/player/jump'
import { handleRecoil } from './modules/player/recoil'
import { handleMuzzleFlash } from './modules/player/muzzleFlash'
import { updateCamera } from './modules/player/camera'
import { updateMovementPhysics } from './modules/player/physics'
import { handleShooting } from './modules/player/shooting'
import { createMuzzleFlashTexture } from './modules/player/textures'
import { MOUSE_SENSITIVITY, MUZZLE_FLASH_LIGHT_DISTANCE } from './modules/player/constants'
import './utils/preload' // Import to trigger preloading

// CDN-based default assets for zero-friction integration
const CDN_BASE = 'https://cdn.jsdelivr.net/npm/tps-controls@latest/public';

// Modify the Player component signature
export function Player({
  modelPath = `${CDN_BASE}/models/player.glb`,
  animationPaths,
  audioPath = `${CDN_BASE}/sfx/pistol-shot.mp3`,
  colliderArgs = [0.5, 0.3],
  mass = 5,
  restitution = 0.3,
  friction = 0.5,
  linearDamping = 0.1,
  angularDamping = 0.1,
  castShadow = false,
  receiveShadow = false,
  ...props 
}: PlayerProps) {
  const group = React.useRef<THREE.Group>(null)
  const mouseRotationRef = React.useRef({x: 0, y: 0});
  const { scene } = useGLTF(modelPath) as unknown as GLTFResult
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult
  
  // Use the modular animation setup with custom paths
  const { actions, mixer, animationClips } = useAnimationSetup(clone, animationPaths);
  
  const [wait, setWait] = React.useState(false);
  const [isJumping, setIsJumping] = React.useState(false);
  const jumpPressedRef = useRef(false);
  const shoot = useRef<boolean>(false);
  const zoom  =  useRef<boolean>(false);
  const shotSfxRef = useRef<THREE.PositionalAudio>(null);
  const leftHandBone = useRef<THREE.Bone | null>(null);
  const rightHandBone = useRef<THREE.Bone | null>(null);
  const rightPalmBone = useRef<THREE.Bone | null>(null);
  const recoilActive = useRef(false);
  const recoilStartTime = useRef(0);
  const leftHandOriginalRotation = useRef(new THREE.Euler());
  const rightHandOriginalRotation = useRef(new THREE.Euler());
  const muzzleFlashRef = useRef<THREE.Mesh>(null);
  const muzzleFlashLightRef = useRef<THREE.PointLight>(null);
  const muzzleFlashActive = useRef(false);
  const muzzleFlashStartTime = useRef(0);
  const gunBarrelRef = useRef<THREE.Vector3>(new THREE.Vector3());

  // Create procedural muzzle flash texture
  const muzzleFlashTexture = React.useMemo(() => createMuzzleFlashTexture(), []);

  // Setup actions with the mixer and clips
  useEffect(() => {
    if (group.current && mixer && animationClips.length > 0) {
      actions[0] = mixer.clipAction(animationClips[0], group.current);
      actions[1] = mixer.clipAction(animationClips[1], group.current);
      actions[2] = mixer.clipAction(animationClips[2], group.current);
      actions[3] = mixer.clipAction(animationClips[3], group.current);
      actions[4] = mixer.clipAction(animationClips[4], group.current);
      actions[5] = mixer.clipAction(animationClips[5], group.current);
      actions[6] = mixer.clipAction(animationClips[6], group.current);
      actions[7] = mixer.clipAction(animationClips[7], group.current);
      actions[8] = mixer.clipAction(animationClips[8], group.current);

      actions[0].play();
    }
  }, [mixer, animationClips, actions]);

  const [action, setAction] = React.useState<THREE.AnimationAction | null>(actions[0])

  const [_, get] = useKeyboardControls();

  // Play the right animation based on the action state
  useEffect(() => {
    if (action) {
      action.reset().fadeIn(0.1).play();

      return () => {
        action.fadeOut(0.1);
      }
    }
  }, [action])

  // PointerLock and mouse movement handling
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if(document.pointerLockElement) {
        mouseRotationRef.current.x += event.movementX * MOUSE_SENSITIVITY;
        mouseRotationRef.current.y += event.movementY * MOUSE_SENSITIVITY;

        const elevation = -Math.PI/5;
        const depression = Math.PI/3;

        mouseRotationRef.current.y = Math.max(elevation, Math.min(depression, mouseRotationRef.current.y)); // Clamp vertical rotation
      }
    }

    const handleCanvasClick = () => {
      if(document.pointerLockElement === null) {
        document.body.requestPointerLock();
      }
    }

    const handleEscapeHit = (e: KeyboardEvent) => {
      if(e.key === 'Escape' && document.pointerLockElement) {
        document.exitPointerLock();
      }
    }

    // Modify the handleMouseDown function to trigger muzzle flash
    const handleMouseDown = (e: MouseEvent) => {
      if (!shoot.current && e.button === 0) { // Left mouse button
        shoot.current = true;
        shotSfxRef.current?.play();
        // Trigger recoil effect
        if (leftHandBone.current && rightHandBone.current) {
          // Store original rotations
          leftHandOriginalRotation.current.copy(leftHandBone.current.rotation);
          rightHandOriginalRotation.current.copy(rightHandBone.current.rotation);
          
          // Start recoil
          recoilActive.current = true;
          recoilStartTime.current = Date.now();
        }

        // Trigger muzzle flash
        muzzleFlashActive.current = true;
        muzzleFlashStartTime.current = Date.now();

        setTimeout(() => {
          shoot.current = false;
        }, 100); // Reset shoot after 100ms
      } else if ( e.button === 2) { // Right mouse button
        if (!zoom.current) {
          // Zoom in
          zoom.current = true;
        }
      }
    }

    const handleMouseUp = (e: MouseEvent) => {
      if(e.button === 2) { // Right mouse button
        // Zoom out
        zoom.current = false;
      }
    }
      
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('click', handleCanvasClick);
    document.addEventListener('keydown', handleEscapeHit);
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('click', handleCanvasClick);
      document.removeEventListener('keydown', handleEscapeHit);
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mouseup', handleMouseUp);
    }
  })

  // Get the reference to the RapierRigidBody
  const controls = useRef<RapierRigidBody>(null);

  // Get bones from the skeleton
  const bones = nodes.Alpha_Joints.skeleton.bones;

  // Add smoothing references
  const smoothedPlayerPosition = useRef(new THREE.Vector3());
  const smoothedCameraPosition = useRef(new THREE.Vector3());

  const shootRayDirection = useRef(new THREE.Vector3());

  const dotRef = useRef<THREE.Mesh>(null);

  const rapier = useRapier();

  useEffect(() => {
    if (bones.length > 0) {
      // Find hand bones in the skeleton
      leftHandBone.current = bones[8];
      rightHandBone.current = bones[32]; 
      rightPalmBone.current = bones[39]; // Right Index Finger

      // Log bone names to help identify the correct hand bones
      console.log('Available bones:', bones.map((bone: THREE.Bone) => bone.name));
    }
  }, [bones]);

  useFrame((state, delta) => {
    const conCurr = controls.current;
    if (!conCurr) return;

    const { forward, backward, left, right, jump, run } = get();

    // Detect single jump press
    const jumpPressed = jump && !jumpPressedRef.current;
    jumpPressedRef.current = jump;

    // Handle movement animations
    handleMovement({
      forward,
      backward,
      left,
      right,
      run,
      jump,
      wait,
      isJumping,
      actions,
      setAction
    });
    
    const world = rapier.world;

    // Implement jump
    const ray = world.castRay(new RAPIER.Ray(conCurr.translation(), {x: 0, y: -1, z: 0}), 0.6, true);
    const isGrounded = ray && ray.collider && Math.abs(ray.timeOfImpact) <= 0.5;

    // Handle jump - only if isGrounded is not null
    if (isGrounded !== null) {
      handleJump({
        jumpPressed,
        isGrounded,
        wait,
        isJumping,
        actions,
        controls,
        setAction,
        setIsJumping,
        setWait
      });
    }

    if (mixer) {
      mixer.update(delta);
    }

    // Handle recoil animation
    handleRecoil({
      recoilActive,
      recoilStartTime,
      leftHandBone,
      rightHandBone,
      leftHandOriginalRotation,
      rightHandOriginalRotation
    });

    // Get mouse rotation values
    const yaw = -mouseRotationRef.current.x;
    const pitch = mouseRotationRef.current.y;

    // Apply YAW to the player (make player rotate with mouse X)
    const playerYRotation = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 1, 0),
      yaw 
    );

    if (group.current) {
      group.current.quaternion.slerp(playerYRotation, zoom.current ? 1 : 0.1);
    }

    // Update movement physics
    updateMovementPhysics({
      forward,
      backward,
      left,
      right,
      run,
      playerYRotation,
      controls,
      smoothedPlayerPosition
    });

    // Handle muzzle flash animation - only if refs are not null
    if (muzzleFlashRef.current && muzzleFlashLightRef.current && group.current) {
      handleMuzzleFlash({
        muzzleFlashActive,
        muzzleFlashStartTime,
        muzzleFlashRef,
        muzzleFlashLightRef,
        gunBarrelRef,
        group,
        bones,
        pitch,
        yaw,
        camera: state.camera
      });
    }

    // Update camera
    updateCamera({
      zoom,
      smoothedPlayerPosition,
      smoothedCameraPosition,
      playerYRotation,
      pitch,
      yaw,
      camera: state.camera,
      world
    });

    // Spine2 rotation for gun aiming
    const spineRotationAxis = new THREE.Vector3(1, 0, -0.5); 
    bones[3].rotation.set(0, 0, 0);
    bones[3].rotateOnAxis(spineRotationAxis, pitch * 0.7);

    // Handle shooting and raycasting - only if controls and dotRef are not null
    if (controls.current && dotRef.current) {
      handleShooting({
        world,
        camera: state.camera,
        controls,
        dotRef,
        shoot,
        shootRayDirection
      });
    }
  })

  return (
    <group>
      <RigidBody
        ref={controls}
        position={props.position}
        type="dynamic"
        mass={mass}
        restitution={restitution}
        friction={friction}
        linearDamping={linearDamping}
        angularDamping={angularDamping}
        canSleep={false}
        colliders={false}
        enabledRotations={[false, false, false]}
        enabledTranslations={[true, true, true]}
      >
        <CapsuleCollider rotation={[0, 0, 0]} args={colliderArgs} position={[0, 0.8, 0]} />
        <group rotation={[0, 0, 0]} ref={group} dispose={null}>
          <group name="Scene">
            <group castShadow={castShadow} receiveShadow={receiveShadow} name="Armature" rotation={[0, 0, 0]} scale={0.01}>
              <primitive object={nodes.mixamorigHips} />
              <skinnedMesh frustumCulled={false} castShadow={castShadow} receiveShadow={receiveShadow} name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} material={materials.Alpha_Joints_MAT} skeleton={nodes.Alpha_Joints.skeleton} />
              <skinnedMesh frustumCulled={false} castShadow={castShadow} receiveShadow={receiveShadow} name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} material={materials.Alpha_Body_MAT} skeleton={nodes.Alpha_Surface.skeleton} />
            </group>
          </group>
        </group>

      <PositionalAudio
        url={audioPath}
        ref={shotSfxRef}
        distance={8}
        loop={false}
        position={[0, 1.5, 0]}
      />
      </RigidBody>

      {/* Muzzle Flash */}
      <mesh ref={muzzleFlashRef} visible={false}>
        <planeGeometry args={[0.5, 0.5]} />
        <meshBasicMaterial 
          map={muzzleFlashTexture}
          transparent
          opacity={0.9}
          blending={THREE.AdditiveBlending}
          depthWrite={false}
          side={THREE.DoubleSide}
        />
      </mesh>

      {/* Muzzle Flash Light */}
      <pointLight
        ref={muzzleFlashLightRef}
        intensity={0}
        distance={MUZZLE_FLASH_LIGHT_DISTANCE}
        decay={2}
        color={0xffa500}
        visible={false}
      />

      <mesh ref={dotRef} visible={false}>
        <sphereGeometry args={[0.1, 16, 16]} />
        <meshStandardMaterial color='red' opacity={1} />
      </mesh>
    </group>
  )
}
