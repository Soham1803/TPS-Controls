/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/player.glb -o src/app/components/Player.tsx 
*/

import * as THREE from 'three'
import type { JSX } from 'react'
import React, { useEffect, useRef } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useKeyboardControls, useFBX, PositionalAudio } from '@react-three/drei'
import type { GLTF } from 'three-stdlib'
import { SkeletonUtils } from 'three-stdlib'
import { CapsuleCollider, RapierRigidBody, RigidBody, useRapier } from '@react-three/rapier'
import RAPIER from '@dimforge/rapier3d-compat'

// import RAPIER from '@dimforge/rapier3d-compat'

const MOVE_SPEED = 2;
const RUN_MULTIPLIER = 2;
const MOUSE_SENSITIVITY = 0.002;
const SHOOT_RAY_OFFSET = 0.5; // Offset from player to avoid self-collision

// const frontVector = new THREE.Vector3();
// const sideVector = new THREE.Vector3();
const directionVector = new THREE.Vector3();

type ActionName = 'idle' | 'forwardWalk' | 'backwardWalk' | 'runForward' | 'runBackward' | 'strafeLeft' | 'strafeRight'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Slide_Highlight_0_1: THREE.Mesh
    Slide_Highlight_0_2: THREE.Mesh
    Slide_Highlight_0_3: THREE.Mesh
    Alpha_Joints: THREE.SkinnedMesh
    Alpha_Surface: THREE.SkinnedMesh
    mixamorigHips: THREE.Bone
  }
  materials: {
    Highlight: THREE.MeshStandardMaterial
    Primary: THREE.MeshStandardMaterial
    Secondary: THREE.MeshStandardMaterial
    Alpha_Joints_MAT: THREE.MeshStandardMaterial
    Alpha_Body_MAT: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

// Add this interface above the Player component
interface PlayerProps extends React.ComponentProps<'group'> {
}

// Modify the Player component signature
export function Player({...props }: PlayerProps) {
  const group = React.useRef<THREE.Group>(null)
  const mouseRotationRef = React.useRef({x: 0, y: 0});
  const { scene } = useGLTF('/models/player.glb') as unknown as GLTFResult
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult
  const mixer = React.useMemo(() => new THREE.AnimationMixer(clone), [clone])
  const actions = React.useMemo(() => [] as THREE.AnimationAction[], []);
  const [wait, setWait] = React.useState(false);
  const [isJumping, setIsJumping] = React.useState(false); // Add jump state
  const jumpPressedRef = useRef(false); // Track jump key state
  const shoot = useRef<boolean>(false); // Track shoot state
  const shotSfxRef = useRef<THREE.PositionalAudio>(null);
  // const [arrowPosition, setArrowPosition] = useState(new THREE.Vector3());
  // const [arrowDirection, setArrowDirection] = useState(new THREE.Vector3());
  let actionAssigned;

  // Import animation from FBX
  const { animations: idle } = useFBX('/animations/pistol-idle.fbx')
  const { animations: walkAhead } = useFBX('/animations/pistol-walk.fbx')
  const { animations: walkBackward } = useFBX('/animations/pistol-walk-backward.fbx')
  const { animations: runAhead } = useFBX('/animations/pistol-run.fbx')
  const { animations: runBackward } = useFBX('/animations/pistol-run-backward.fbx')
  const { animations: strafeLeft } = useFBX('/animations/pistol-strafe-left.fbx')
  const { animations: strafeRight } = useFBX('/animations/pistol-strafe-right.fbx')
  const { animations: jump1 } = useFBX('/animations/pistol-jump-1.fbx')
  const { animations: jump2 } = useFBX('/animations/pistol-jump-2.fbx')
  
  // Clone and rename all animations in a single useMemo
  const animationClips = React.useMemo(() => {
    return [
      idle[0].clone(),
      walkAhead[0].clone(),
      walkBackward[0].clone(),
      runAhead[0].clone(),
      runBackward[0].clone(),
      strafeLeft[0].clone(),
      strafeRight[0].clone(),
      jump1[0].clone(),
      jump2[0].clone()
    ]
  }, [idle, walkAhead, walkBackward, runAhead, runBackward, strafeLeft, strafeRight, jump1, jump2]);

  useEffect(() => {
    if (group.current) {
      actions[0] = mixer.clipAction(animationClips[0], group.current);
      actions[1] = mixer.clipAction(animationClips[1], group.current);
      actions[2] = mixer.clipAction(animationClips[2], group.current);
      actions[3] = mixer.clipAction(animationClips[3], group.current);
      actions[4] = mixer.clipAction(animationClips[4], group.current);
      actions[5] = mixer.clipAction(animationClips[5], group.current);
      actions[6] = mixer.clipAction(animationClips[6], group.current);
      actions[7] = mixer.clipAction(animationClips[7], group.current);
      actions[8] = mixer.clipAction(animationClips[8], group.current);

      // actions[0].setLoop(THREE.LoopRepeat, Infinity);
      actions[0].play();
    }
  })

  animationClips[0].name = 'idle'
  animationClips[1].name = 'forwardWalk'
  animationClips[2].name = 'backwardWalk'
  animationClips[3].name = 'runForward'
  animationClips[4].name = 'runBackward'
  animationClips[5].name = 'strafeLeft'
  animationClips[6].name = 'strafeRight'
  animationClips[7].name = 'jump1'
  animationClips[8].name = 'jump2'

  const [action, setAction] = React.useState<THREE.AnimationAction | null>(actions[0])

  const [_, get] = useKeyboardControls();

  // Play the right animation based on the action state
  useEffect(() => {
    if (action) {
      action.reset().fadeIn(0.1).play();

      return () => {
        action.fadeOut(0.1);
      }
    }
  }, [action])

  // PointerLock and mouse movement handling
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if(document.pointerLockElement) {
        mouseRotationRef.current.x += event.movementX * MOUSE_SENSITIVITY;
        mouseRotationRef.current.y += event.movementY * MOUSE_SENSITIVITY;

        mouseRotationRef.current.y = Math.max(-Math.PI/6, Math.min(Math.PI / 2, mouseRotationRef.current.y)); // Clamp vertical rotation
      }
    }

    const handleCanvasClick = () => {
      if(document.pointerLockElement === null) {
        document.body.requestPointerLock();
      }
    }

    const handleEscapeHit = (e: KeyboardEvent) => {
      if(e.key === 'Escape' && document.pointerLockElement) {
        document.exitPointerLock();
      }
    }

    const handleMouseDown = (e: MouseEvent) => {
      shotSfxRef.current?.play();
      if (!shoot.current && e.button === 0) { // Left mouse button
        shoot.current = true;

        setTimeout(() => {
          shoot.current = false;
          console.log("Time: ", Date.now());
        }
        , 100); // Reset shoot after 100ms
      }
    }
      
  
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('click', handleCanvasClick);
    document.addEventListener('keydown', handleEscapeHit);
    document.addEventListener('mousedown', handleMouseDown);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('click', handleCanvasClick);
      document.removeEventListener('keydown', handleEscapeHit);
      document.removeEventListener('mousedown', handleMouseDown);
    }

  })

  // Get the reference to the RapierRigidBody
  const controls = useRef<RapierRigidBody>(null);

  // Get bones from the skeleton
  const bones = nodes.Alpha_Joints.skeleton.bones;

  // Add smoothing references
  const smoothedPlayerPosition = useRef(new THREE.Vector3());
  const smoothedCameraPosition = useRef(new THREE.Vector3());

  const shootRayDirection = useRef(new THREE.Vector3());

  const dotRef = useRef<THREE.Mesh>(null);

  const rapier = useRapier();

  useFrame((state, delta) => {
    const conCurr = controls.current;
    if (!conCurr) return;

    const { forward, backward, left, right, jump, run } = get();

    // Detect single jump press
    const jumpPressed = jump && !jumpPressedRef.current;
    jumpPressedRef.current = jump;

    actionAssigned = false;
    
    // Only allow movement animations if not jumping
    if(!wait && !isJumping) {
      if (forward || backward) {
        if (run) {
          setAction(actions[forward ? 3 : 4]);
          actionAssigned = true;
        } else {
          setAction(actions[forward ? 1 : 2]);
          actionAssigned = true;
        }

        if(jump) {
          setAction(actions[8]); // Set jump animation based on direction
          actionAssigned = true;
        }
      }
      if (left || right) {
        setAction(actions[left ? 5 : 6]);
        actionAssigned = true;
      }

      if (!actionAssigned) {
        setAction(actions[0]);
      }
    }
    
    const world = rapier.world;

    // Implement jump
    const ray = world.castRay(new RAPIER.Ray(conCurr.translation(), {x: 0, y: -1, z: 0}), 0.6, true);
    const isGrounded = ray && ray.collider && Math.abs(ray.timeOfImpact) <= 0.5;

    // Handle jump on single press
    if(jumpPressed && isGrounded && !wait && !isJumping) {

      setAction(actions[8]); // Play jump animation
      setIsJumping(true);
      setWait(true);
      
      const jumpDuration = actions[8].getClip().duration; // Get jump animation duration

      setTimeout(() => {  
        conCurr.applyImpulse({x: 0, y: 1.3, z: 0}, true);
      }, 0); // Delay impulse to sync with animation
      
      // Set jump animation duration (adjust based on your animation length)
      setTimeout(() => {
        setIsJumping(false);
      }, jumpDuration*1000); // 1 second - adjust this to match your jump animation duration
    }

    if(isGrounded && wait && !isJumping) {
      setWait(false);
    }

    mixer.update(delta);

    // Get mouse rotation values
    const yaw = -mouseRotationRef.current.x;
    const pitch = mouseRotationRef.current.y;

    // Apply YAW to the player (make player rotate with mouse X)
    const playerYRotation = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 1, 0),
      yaw 
    );

    if (group.current) {
      group.current.quaternion.slerp(playerYRotation, 0.1);
    }

    // Calculate player's forward direction for movement
    const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYRotation);
    const playerRight = new THREE.Vector3().crossVectors(playerForward, new THREE.Vector3(0, 1, 0));

    // Movement calculation based on player's orientation
    const moveForward = -(Number(forward) - Number(backward)) * MOVE_SPEED * (run ? RUN_MULTIPLIER : 1);
    const moveRight = -(Number(right) - Number(left)) * MOVE_SPEED * (run ? RUN_MULTIPLIER : 1);

    directionVector
      .copy(playerForward)
      .multiplyScalar(moveForward)
      .add(playerRight.multiplyScalar(moveRight));

    const velocity = conCurr.linvel();
    controls.current?.setLinvel({
      x: directionVector.x,
      y: velocity.y,
      z: directionVector.z,
    }, true);

    // Smooth the player position used for camera calculations
    const currentPlayerPos = new THREE.Vector3(
      conCurr.translation().x,
      conCurr.translation().y + 1.55,
      conCurr.translation().z
    );

    // shotSfxRef.current?.translateX(conCurr.translation().x/100);
    // shotSfxRef.current?.translateY(conCurr.translation().y + 1.55);
    // shotSfxRef.current?.translateZ(conCurr.translation().z/100);

    smoothedPlayerPosition.current.lerp(currentPlayerPos, 0.15);

    // const positionHelper = new PositionalAudioHelper(shotSfxRef.current!, 10);
    // positionHelper.update();
    // positionHelper.scale.set(10, 10, 10);
    // shotSfxRef.current?.add(positionHelper);

    // Camera positioning - behind and above the player
    const cameraDistance = 4 * Math.sin(pitch) + 3; // Adjust camera distance based on pitch
    const baseCameraHeight = 1.6; // Base height of the camera above the player

    const orbitAngle = pitch;

    const cameraOffset = new THREE.Vector3(
      0, 
      Math.sin(orbitAngle) * cameraDistance + baseCameraHeight, // Adjust height based on pitch
      -Math. cos(orbitAngle) * cameraDistance
    ); // Move camera further back

    cameraOffset.applyQuaternion(playerYRotation);

    const targetCameraPos = new THREE.Vector3(
      smoothedPlayerPosition.current.x + cameraOffset.x,
      smoothedPlayerPosition.current.y + cameraOffset.y - 1.6, // Subtract the offset we added
      smoothedPlayerPosition.current.z + cameraOffset.z
    );

    smoothedCameraPosition.current.lerp(targetCameraPos, 0.1);
    state.camera.position.copy(smoothedCameraPosition.current);

    // Camera rotation - look at player with pitch adjustment
    state.camera.lookAt(smoothedPlayerPosition.current.clone().add(new THREE.Vector3(0, 0.5, 0)));

    // Spine2 rotation for gun aiming
    const spineRotationAxis = new THREE.Vector3(1, 0, -0.5); 
    bones[3].rotation.set(0, 0, 0);
    bones[3].rotateOnAxis(spineRotationAxis, pitch * 0.7);

    const newDirection = state.camera.getWorldDirection(new THREE.Vector3());
    shootRayDirection.current = newDirection;
    // setArrowDirection(newDirection);

    const rayOrigin = new THREE.Vector3()
      .copy(smoothedPlayerPosition.current)
      .add(new THREE.Vector3(
        shootRayDirection.current.x * SHOOT_RAY_OFFSET,
        0.5, // Offset upward to match gun position
        shootRayDirection.current.z * SHOOT_RAY_OFFSET
      ));

    const shootRay = world.castRay(
      new RAPIER.Ray(
        rayOrigin,
        shootRayDirection.current
      ), 
      100, 
      true
    );
 
    // Update arrow helper position to match ray origin
    // setArrowPosition(rayOrigin);

    // Modify the raycast check to exclude self-collision
    if (shootRay && shootRay.collider && shootRay.collider.parent() !== controls.current) {
      // console.log('Hit target:', shootRay.collider.parent());
      
      // Apply impulse to hit target
      const hitRigidBody = shootRay.collider.parent();
      if (hitRigidBody && hitRigidBody.isValid()) {
        const impulseStrength = 0.025;
        const impulsePoint = new THREE.Vector3()
          .copy(rayOrigin)
          .add(shootRayDirection.current.multiplyScalar(shootRay.timeOfImpact));

        dotRef.current!.position.copy(impulsePoint)
       
        if(shoot.current) {
          hitRigidBody.applyImpulseAtPoint(
            {
              x: shootRayDirection.current.x * impulseStrength,
              y: shootRayDirection.current.y * impulseStrength,
              z: shootRayDirection.current.z * impulseStrength
            },
            impulsePoint,
            true
          );
        }
      }
    }

  })

  return (
    <group>
      <RigidBody
        ref={controls}
        position={props.position}
        // rotation={props.rotation}
        type="dynamic"
        mass={5}
        restitution={0.3}
        friction={0.5}
        linearDamping={0.1}
        angularDamping={0.1}
        canSleep={false}
        colliders={false}
        enabledRotations={[false, false, false]}
        enabledTranslations={[true, true, true]}
      >
        <CapsuleCollider rotation={[0, 0, 0]} args={[0.5, 0.3]} position={[0, 0.8, 0]} />
        <group rotation={[0, 0, 0]} ref={group} dispose={null}>
          <group name="Scene">
            <group castShadow receiveShadow name="Armature" rotation={[0, 0, 0]} scale={0.01}>
              {/* <axesHelper args={[500]} /> */}
              <primitive object={nodes.mixamorigHips} />
              <skinnedMesh frustumCulled={false} castShadow receiveShadow name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} material={materials.Alpha_Joints_MAT} skeleton={nodes.Alpha_Joints.skeleton} />
              <skinnedMesh frustumCulled={false} castShadow receiveShadow name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} material={materials.Alpha_Body_MAT} skeleton={nodes.Alpha_Surface.skeleton} />
            </group>
          </group>
        </group>

      <PositionalAudio
        url="/sfx/pistol-shot.mp3"
        ref={shotSfxRef}
        distance={8}
        loop={false}
        position={[0, 1.5, 0]}
      />
      </RigidBody>

      {/* <arrowHelper 
        args={[
          arrowDirection, // use state instead of ref
          arrowPosition, // use state instead of ref
          1,
          0x00ff00,
          0.1,
          0.05
        ]}
      /> */}
      
      {/* Visualization helpers */}
      {/* {visualHelpers.showHelpers && (
        <>
          <arrowHelper 
            args={[
              visualHelpers.perpAxisDirection, 
              visualHelpers.perpAxisOrigin, 
              1, // length
              0xff0000, // color (red)
              0.1, // head length
              0.05 // head width
            ]} 
          />
          <arrowHelper
            args={[
              arrowHelper.direction,
              arrowHelper.origin,
              1, // length
              0x00ff00, // color (green)
              0.1, // head length
              0.05 // head width
            ]}
          />
          <axesHelper 
            position={visualHelpers.perpAxisOrigin} 
            args={[0.5]} // size of axes
          />
        </>
      )} */}
      <mesh ref={dotRef}>
        <sphereGeometry args={[0.1, 16, 16]} />
        <meshBasicMaterial color="red" />
      </mesh>
    </group>
  )
}

useGLTF.preload('/models/player.glb')
