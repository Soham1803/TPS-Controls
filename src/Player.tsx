/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/player.glb -o src/app/components/Player.tsx 
*/

import * as THREE from 'three'
import type { JSX } from 'react'
import React, { useEffect, useRef } from 'react'
import { useFrame, useGraph } from '@react-three/fiber'
import { useGLTF, useKeyboardControls, useFBX, PositionalAudio } from '@react-three/drei'
import type { GLTF } from 'three-stdlib'
import { SkeletonUtils } from 'three-stdlib'
import { CapsuleCollider, RapierRigidBody, RigidBody, useRapier } from '@react-three/rapier'
import RAPIER from '@dimforge/rapier3d-compat'

// import RAPIER from '@dimforge/rapier3d-compat'

const MOVE_SPEED = 2;
const RUN_MULTIPLIER = 2;
const MOUSE_SENSITIVITY = 0.002;
const SHOOT_RAY_OFFSET = 0.5; // Offset from player to avoid self-collision
const RECOIL_STRENGTH = 0.1;
const RECOIL_DURATION = 150; // milliseconds
const MUZZLE_FLASH_DURATION = 50; // milliseconds - very quick flash
const MUZZLE_FLASH_LIGHT_INTENSITY = 15;
const MUZZLE_FLASH_LIGHT_DISTANCE = 8;

// Zoom (ADS) tuning
const ZOOM_SHOULDER_X = 0.3;   // left shoulder (negative is left in player local)
const ZOOM_SHOULDER_Y = 0.1;    // height above player origin
const ZOOM_SHOULDER_Z = -0.3;    // slightly behind player (forward is -Z)
const DEFAULT_CAMERA_FOV = 75;
const ZOOM_CAMERA_FOV = 50;

// const frontVector = new THREE.Vector3();
// const sideVector = new THREE.Vector3();
const directionVector = new THREE.Vector3();

type ActionName = 'idle' | 'forwardWalk' | 'backwardWalk' | 'runForward' | 'runBackward' | 'strafeLeft' | 'strafeRight'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Slide_Highlight_0_1: THREE.Mesh
    Slide_Highlight_0_2: THREE.Mesh
    Slide_Highlight_0_3: THREE.Mesh
    Alpha_Joints: THREE.SkinnedMesh
    Alpha_Surface: THREE.SkinnedMesh
    mixamorigHips: THREE.Bone
  }
  materials: {
    Highlight: THREE.MeshStandardMaterial
    Primary: THREE.MeshStandardMaterial
    Secondary: THREE.MeshStandardMaterial
    Alpha_Joints_MAT: THREE.MeshStandardMaterial
    Alpha_Body_MAT: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

// Add this interface above the Player component
interface PlayerProps extends React.ComponentProps<'group'> {
}

// Modify the Player component signature
export function Player({...props }: PlayerProps) {
  const group = React.useRef<THREE.Group>(null)
  const mouseRotationRef = React.useRef({x: 0, y: 0});
  const { scene } = useGLTF('/models/player.glb') as unknown as GLTFResult
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult
  const mixer = React.useMemo(() => new THREE.AnimationMixer(clone), [clone])
  const actions = React.useMemo(() => [] as THREE.AnimationAction[], []);
  const [wait, setWait] = React.useState(false);
  const [isJumping, setIsJumping] = React.useState(false); // Add jump state
  const jumpPressedRef = useRef(false); // Track jump key state
  const shoot = useRef<boolean>(false); // Track shoot state
  const zoom  =  useRef<boolean>(false); // Track zoom state
  const shotSfxRef = useRef<THREE.PositionalAudio>(null);
  const leftHandBone = useRef<THREE.Bone | null>(null);
  const rightHandBone = useRef<THREE.Bone | null>(null);
  const rightPalmBone = useRef<THREE.Bone | null>(null);
  const recoilActive = useRef(false);
  const recoilStartTime = useRef(0);
  const leftHandOriginalRotation = useRef(new THREE.Euler());
  const rightHandOriginalRotation = useRef(new THREE.Euler());
  const muzzleFlashRef = useRef<THREE.Mesh>(null);
  const muzzleFlashLightRef = useRef<THREE.PointLight>(null);
  const muzzleFlashActive = useRef(false);
  const muzzleFlashStartTime = useRef(0);
  const gunBarrelRef = useRef<THREE.Vector3>(new THREE.Vector3());

  // const [arrowPosition, setArrowPosition] = useState(new THREE.Vector3());
  // const [arrowDirection, setArrowDirection] = useState(new THREE.Vector3());
  let actionAssigned;

  // Create procedural muzzle flash texture
  const createMuzzleFlashTexture = React.useMemo(() => {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d')!;
    
    // Create radial gradient for flash effect
    const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // Bright white center
    gradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');  // Orange-yellow
    gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.4)');    // Orange fade
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');          // Transparent red edge
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
    
    // Add some noise/texture for realism
    const imageData = ctx.getImageData(0, 0, 128, 128);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      // Add slight random variation to alpha channel
      data[i + 3] *= (0.8 + Math.random() * 0.4);
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
  }, []);

  // Import animation from FBX
  const { animations: idle } = useFBX('/animations/pistol-idle.fbx')
  const { animations: walkAhead } = useFBX('/animations/pistol-walk.fbx')
  const { animations: walkBackward } = useFBX('/animations/pistol-walk-backward.fbx')
  const { animations: runAhead } = useFBX('/animations/pistol-run.fbx')
  const { animations: runBackward } = useFBX('/animations/pistol-run-backward.fbx')
  const { animations: strafeLeft } = useFBX('/animations/pistol-strafe-left.fbx')
  const { animations: strafeRight } = useFBX('/animations/pistol-strafe-right.fbx')
  const { animations: jump1 } = useFBX('/animations/pistol-jump-1.fbx')
  const { animations: jump2 } = useFBX('/animations/pistol-jump-2.fbx')
  
  // Clone and rename all animations in a single useMemo
  const animationClips = React.useMemo(() => {
    return [
      idle[0].clone(),
      walkAhead[0].clone(),
      walkBackward[0].clone(),
      runAhead[0].clone(),
      runBackward[0].clone(),
      strafeLeft[0].clone(),
      strafeRight[0].clone(),
      jump1[0].clone(),
      jump2[0].clone()
    ]
  }, [idle, walkAhead, walkBackward, runAhead, runBackward, strafeLeft, strafeRight, jump1, jump2]);

  useEffect(() => {
    if (group.current) {
      actions[0] = mixer.clipAction(animationClips[0], group.current);
      actions[1] = mixer.clipAction(animationClips[1], group.current);
      actions[2] = mixer.clipAction(animationClips[2], group.current);
      actions[3] = mixer.clipAction(animationClips[3], group.current);
      actions[4] = mixer.clipAction(animationClips[4], group.current);
      actions[5] = mixer.clipAction(animationClips[5], group.current);
      actions[6] = mixer.clipAction(animationClips[6], group.current);
      actions[7] = mixer.clipAction(animationClips[7], group.current);
      actions[8] = mixer.clipAction(animationClips[8], group.current);

      // actions[0].setLoop(THREE.LoopRepeat, Infinity);
      actions[0].play();
    }
  })

  animationClips[0].name = 'idle'
  animationClips[1].name = 'forwardWalk'
  animationClips[2].name = 'backwardWalk'
  animationClips[3].name = 'runForward'
  animationClips[4].name = 'runBackward'
  animationClips[5].name = 'strafeLeft'
  animationClips[6].name = 'strafeRight'
  animationClips[7].name = 'jump1'
  animationClips[8].name = 'jump2'

  const [action, setAction] = React.useState<THREE.AnimationAction | null>(actions[0])

  const [_, get] = useKeyboardControls();

  // Play the right animation based on the action state
  useEffect(() => {
    if (action) {
      action.reset().fadeIn(0.1).play();

      return () => {
        action.fadeOut(0.1);
      }
    }
  }, [action])

  // PointerLock and mouse movement handling
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if(document.pointerLockElement) {
        mouseRotationRef.current.x += event.movementX * MOUSE_SENSITIVITY;
        mouseRotationRef.current.y += event.movementY * MOUSE_SENSITIVITY;

        mouseRotationRef.current.y = Math.max(-Math.PI/6, Math.min(Math.PI / 3, mouseRotationRef.current.y)); // Clamp vertical rotation
      }
    }

    const handleCanvasClick = () => {
      if(document.pointerLockElement === null) {
        document.body.requestPointerLock();
      }
    }

    const handleEscapeHit = (e: KeyboardEvent) => {
      if(e.key === 'Escape' && document.pointerLockElement) {
        document.exitPointerLock();
      }
    }

    // Modify the handleMouseDown function to trigger muzzle flash
    const handleMouseDown = (e: MouseEvent) => {
      if (!shoot.current && e.button === 0) { // Left mouse button
        shoot.current = true;
        shotSfxRef.current?.play();
        // Trigger recoil effect
        if (leftHandBone.current && rightHandBone.current) {
          // Store original rotations
          leftHandOriginalRotation.current.copy(leftHandBone.current.rotation);
          rightHandOriginalRotation.current.copy(rightHandBone.current.rotation);
          
          // Start recoil
          recoilActive.current = true;
          recoilStartTime.current = Date.now();
        }

        // Trigger muzzle flash
        muzzleFlashActive.current = true;
        muzzleFlashStartTime.current = Date.now();

        setTimeout(() => {
          shoot.current = false;
        }, 100); // Reset shoot after 100ms
      } else if ( e.button === 2) { // Right mouse button
        if (!zoom.current) {
          // Zoom in
          zoom.current = true;
        }
      }
    }

    const handleMouseUp = (e: MouseEvent) => {
      if(e.button === 2) { // Right mouse button
        // Zoom out
        zoom.current = false;
      }
    }
      
  
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('click', handleCanvasClick);
    document.addEventListener('keydown', handleEscapeHit);
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('click', handleCanvasClick);
      document.removeEventListener('keydown', handleEscapeHit);
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mouseup', handleMouseUp);
    }

  })

  // Get the reference to the RapierRigidBody
  const controls = useRef<RapierRigidBody>(null);

  // Get bones from the skeleton
  const bones = nodes.Alpha_Joints.skeleton.bones;

  // Add smoothing references
  const smoothedPlayerPosition = useRef(new THREE.Vector3());
  const smoothedCameraPosition = useRef(new THREE.Vector3());

  const shootRayDirection = useRef(new THREE.Vector3());

  const dotRef = useRef<THREE.Mesh>(null);

  const rapier = useRapier();

  useEffect(() => {
    if (bones.length > 0) {
      // Find hand bones in the skeleton
      // These names might vary based on your model's bone naming convention
      leftHandBone.current = bones[8];
      
      rightHandBone.current = bones[32]; 

      rightPalmBone.current = bones[39]; // Right Index Finger

      // Log bone names to help identify the correct hand bones
      console.log('Available bones:', bones.map(bone => bone.name));
    }
  }, [bones]);

  useFrame((state, delta) => {
    const conCurr = controls.current;
    if (!conCurr) return;

    const { forward, backward, left, right, jump, run } = get();

    // Detect single jump press
    const jumpPressed = jump && !jumpPressedRef.current;
    jumpPressedRef.current = jump;

    actionAssigned = false;
    
    // Only allow movement animations if not jumping
    if(!wait && !isJumping) {
      if (forward || backward) {
        if (run) {
          setAction(actions[forward ? 3 : 4]);
          actionAssigned = true;
        } else {
          setAction(actions[forward ? 1 : 2]);
          actionAssigned = true;
        }

        if(jump) {
          setAction(actions[8]); // Set jump animation based on direction
          actionAssigned = true;
        }
      }
      if (left || right) {
        setAction(actions[left ? 5 : 6]);
        actionAssigned = true;
      }

      if (!actionAssigned) {
        setAction(actions[0]);
      }
    }
    
    const world = rapier.world;

    // Implement jump
    const ray = world.castRay(new RAPIER.Ray(conCurr.translation(), {x: 0, y: -1, z: 0}), 0.6, true);
    const isGrounded = ray && ray.collider && Math.abs(ray.timeOfImpact) <= 0.5;

    // Handle jump on single press
    if(jumpPressed && isGrounded && !wait && !isJumping) {

      setAction(actions[8]); // Play jump animation
      setIsJumping(true);
      setWait(true);
      
      const jumpDuration = actions[8].getClip().duration; // Get jump animation duration

      setTimeout(() => {  
        conCurr.applyImpulse({x: 0, y: 1.3, z: 0}, true);
      }, 0); // Delay impulse to sync with animation
      
      // Set jump animation duration (adjust based on your animation length)
      setTimeout(() => {
        setIsJumping(false);
      }, jumpDuration*1000); // 1 second - adjust this to match your jump animation duration
    }

    if(isGrounded && wait && !isJumping) {
      setWait(false);
    }

    mixer.update(delta);

    // Handle recoil animation
    if (recoilActive.current && leftHandBone.current && rightHandBone.current) {
      const currentTime = Date.now();
      const elapsedTime = currentTime - recoilStartTime.current;
      const progress = Math.min(elapsedTime / RECOIL_DURATION, 1);

      if (progress < 1) {
        // Apply recoil with easing (quick up, slow down)
        const recoilIntensity = Math.sin(progress * Math.PI) * RECOIL_STRENGTH;
        
        // Apply the recoil rotation
        leftHandBone.current.rotation.copy(leftHandOriginalRotation.current);
        rightHandBone.current.rotation.copy(rightHandOriginalRotation.current);
        
        // leftHandBone.current.rotation.x -= recoilIntensity;
        // rightHandBone.current.rotation.x -= recoilIntensity;
        
        // Optional: Add slight side-to-side motion for more realism
        leftHandBone.current.rotation.z += recoilIntensity * 0.05;
        rightHandBone.current.rotation.z -= recoilIntensity * 0.05;
      } else {
        // Reset to original positions
        leftHandBone.current.rotation.copy(leftHandOriginalRotation.current);
        rightHandBone.current.rotation.copy(rightHandOriginalRotation.current);
        recoilActive.current = false;
      }
    }

    // Get mouse rotation values
    const yaw = -mouseRotationRef.current.x;
    const pitch = mouseRotationRef.current.y;

    // Handle muzzle flash animation
    if (muzzleFlashActive.current) {
      const currentTime = Date.now();
      const elapsedTime = currentTime - muzzleFlashStartTime.current;
      const progress = Math.min(elapsedTime / MUZZLE_FLASH_DURATION, 1);

      if (progress < 1) {
        // Calculate gun barrel position (approximate position in front of right hand)
        if (rightPalmBone.current && group.current) {
          const handWorldPosition = new THREE.Vector3();
          rightPalmBone.current.getWorldPosition(handWorldPosition);
          
          // Offset forward from the hand to simulate gun barrel
          const gunOffset = new THREE.Vector3(0, 0, 0); // Adjust based on your gun model
          const mflashQuat = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(-pitch, yaw, 0, 'XYZ')
          )
          gunOffset.applyQuaternion(mflashQuat);
          gunBarrelRef.current.copy(handWorldPosition).add(gunOffset);
        }

        // Flash intensity with quick fade
        const flashIntensity = 1 - Math.pow(progress, 2); // Quick fade out
        
        // Update muzzle flash position and visibility
        if (muzzleFlashRef.current) {
          muzzleFlashRef.current.position.copy(gunBarrelRef.current);
          muzzleFlashRef.current.lookAt(state.camera.position); // Always face camera
          muzzleFlashRef.current.visible = true;
          
          // Scale variation for more dynamic effect
          const scale = 0.3 + Math.random() * 0.2; // Random scale between 0.3-0.5
          muzzleFlashRef.current.scale.setScalar(scale * flashIntensity);
          
          // Rotate randomly for variety
          muzzleFlashRef.current.rotation.z = Math.random() * Math.PI * 2;
        }

        // Update muzzle flash light
        if (muzzleFlashLightRef.current) {
          muzzleFlashLightRef.current.position.copy(gunBarrelRef.current.clone().add(new THREE.Vector3(0, 0.1, 0.3)));
          muzzleFlashLightRef.current.intensity = MUZZLE_FLASH_LIGHT_INTENSITY * flashIntensity;
          muzzleFlashLightRef.current.visible = true;
        }
      } else {
        // Hide flash when animation is complete
        if (muzzleFlashRef.current) {
          muzzleFlashRef.current.visible = false;
        }
        if (muzzleFlashLightRef.current) {
          muzzleFlashLightRef.current.visible = false;
        }
        muzzleFlashActive.current = false;
      }
    }

    // Apply YAW to the player (make player rotate with mouse X)
    const playerYRotation = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 1, 0),
      yaw 
    );

    if (group.current) {
      group.current.quaternion.slerp(playerYRotation, zoom.current ? 0.99 : 0.1);
    }

    // Calculate player's forward direction for movement
    const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerYRotation);
    const playerRight = new THREE.Vector3().crossVectors(playerForward, new THREE.Vector3(0, 1, 0));

    // Movement calculation based on player's orientation
    const moveForward = -(Number(forward) - Number(backward)) * MOVE_SPEED * (run ? RUN_MULTIPLIER : 1);
    const moveRight = -(Number(right) - Number(left)) * MOVE_SPEED * (run ? RUN_MULTIPLIER : 1);

    directionVector
      .copy(playerForward)
      .multiplyScalar(moveForward)
      .add(playerRight.multiplyScalar(moveRight));

    const velocity = conCurr.linvel();
    controls.current?.setLinvel({
      x: directionVector.x,
      y: velocity.y,
      z: directionVector.z,
    }, true);

    // Smooth the player position used for camera calculations
    const currentPlayerPos = new THREE.Vector3(
      conCurr.translation().x,
      conCurr.translation().y + 1.55,
      conCurr.translation().z
    );

    // shotSfxRef.current?.translateX(conCurr.translation().x/100);
    // shotSfxRef.current?.translateY(conCurr.translation().y + 1.55);
    // shotSfxRef.current?.translateZ(conCurr.translation().z/100);

    smoothedPlayerPosition.current.lerp(currentPlayerPos, 0.15);

    // const positionHelper = new PositionalAudioHelper(shotSfxRef.current!, 10);
    // positionHelper.update();
    // positionHelper.scale.set(10, 10, 10);
    // shotSfxRef.current?.add(positionHelper);

    // Camera positioning
    let targetCameraPos: THREE.Vector3;

    // if (zoom.current) {
    //   // Over-left-shoulder camera when zoomed
    //   const shoulderOffset = new THREE.Vector3(
    //     ZOOM_SHOULDER_X,
    //     ZOOM_SHOULDER_Y,
    //     ZOOM_SHOULDER_Z
    //   ).applyQuaternion(playerYRotation);

    //   targetCameraPos = new THREE.Vector3(
    //     smoothedPlayerPosition.current.x + shoulderOffset.x,
    //     smoothedPlayerPosition.current.y + shoulderOffset.y,
    //     smoothedPlayerPosition.current.z + shoulderOffset.z
    //   );
    // } else {
      // Default third-person orbit camera
      const amplitude = zoom.current ? 0.2 : 4;
      const adder = zoom.current ? 0.1 : 3;
      const zoomAdjuster = zoom.current ? Math.cos(pitch) : Math.sin(pitch);
      const cameraDistance = amplitude * (zoomAdjuster) + adder; // Adjust camera distance based on pitch
      const baseCameraHeight = zoom.current ? 1.65 : 1.5; // Base height of the camera above the player
      const orbitAngle = pitch;

      const cameraOffset = new THREE.Vector3(
        zoom.current ? -0.35 : 0,
        Math.sin(orbitAngle) * cameraDistance + baseCameraHeight, // Adjust height based on pitch
        -Math.cos(orbitAngle) * cameraDistance
      ); // Move camera further back

      cameraOffset.applyQuaternion(playerYRotation);

      targetCameraPos = new THREE.Vector3(
        smoothedPlayerPosition.current.x + cameraOffset.x,
        smoothedPlayerPosition.current.y + cameraOffset.y - 1.6, // Subtract the offset we added
        smoothedPlayerPosition.current.z + cameraOffset.z
      );
    // }    // Get mouse rotation values

    // Smooth camera movement (slightly faster when zoomed)
    smoothedCameraPosition.current.lerp(targetCameraPos, zoom.current ? 0.1 : 0.1);
    state.camera.position.copy(smoothedCameraPosition.current);

    // Smooth FOV transition between default and zoom FOV
    const targetFov = zoom.current ? ZOOM_CAMERA_FOV : DEFAULT_CAMERA_FOV;
    state.camera.fov += (targetFov - state.camera.fov) * 0.15;
    state.camera.zoom = zoom.current ? 1 : 2;
    state.camera.updateProjectionMatrix();

    // Camera rotation
    if (zoom.current) {
      // Look in the direction of the gun point
      // Use right palm as aim origin if available
      const aimOrigin = new THREE.Vector3();
     
      aimOrigin.copy(smoothedPlayerPosition.current).add(new THREE.Vector3(0, 1.5, 0));
      

      // Compute aim direction from yaw/pitch (match shooting direction)
      const aimQuat = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(-pitch, yaw + Math.PI, 0, 'YXZ')
      );
      const aimDir = new THREE.Vector3(0.1, 0, -1).applyQuaternion(aimQuat);

      const aimTarget = aimOrigin.clone().add(aimDir.multiplyScalar(10));
      state.camera.lookAt(aimTarget);
    } else {
      // Default: look at player
      state.camera.lookAt(
        smoothedPlayerPosition.current.clone().add(new THREE.Vector3(0, 0.5, 0))
      );
    }

    // Spine2 rotation for gun aiming
    const spineRotationAxis = new THREE.Vector3(1, 0, -0.5); 
    bones[3].rotation.set(0, 0, 0);
    bones[3].rotateOnAxis(spineRotationAxis, pitch * 0.7);

    const newDirection = state.camera.getWorldDirection(new THREE.Vector3());
    shootRayDirection.current = newDirection;
    // setArrowDirection(newDirection);

    const rayOrigin = new THREE.Vector3().copy(state.camera.position)
  

    const shootRay = world.castRay(
      new RAPIER.Ray(
        rayOrigin,
        shootRayDirection.current
      ), 
      100, 
      true
    );
 
    // Update arrow helper position to match ray origin
    // setArrowPosition(rayOrigin);

    // Modify the raycast check to exclude self-collision
    if (shootRay && shootRay.collider && shootRay.collider.parent() !== controls.current) {
      // console.log('Hit target:', shootRay.collider.parent());
      
      // Apply impulse to hit target
      const hitRigidBody = shootRay.collider.parent();
      if (hitRigidBody && hitRigidBody.isValid()) {
        const impulseStrength = 0.025;
        const impulsePoint = new THREE.Vector3()
          .copy(rayOrigin)
          .add(shootRayDirection.current.multiplyScalar(shootRay.timeOfImpact));

        dotRef.current!.position.copy(impulsePoint)
       
        if(shoot.current) {
          hitRigidBody.applyImpulseAtPoint(
            {
              x: shootRayDirection.current.x * impulseStrength,
              y: shootRayDirection.current.y * impulseStrength,
              z: shootRayDirection.current.z * impulseStrength
            },
            impulsePoint,
            true
          );
        }
      }
    }


  })

  return (
    <group>
      <RigidBody
        ref={controls}
        position={props.position}
        // rotation={props.rotation}
        type="dynamic"
        mass={5}
        restitution={0.3}
        friction={0.5}
        linearDamping={0.1}
        angularDamping={0.1}
        canSleep={false}
        colliders={false}
        enabledRotations={[false, false, false]}
        enabledTranslations={[true, true, true]}
      >
        <CapsuleCollider rotation={[0, 0, 0]} args={[0.5, 0.3]} position={[0, 0.8, 0]} />
        <group rotation={[0, 0, 0]} ref={group} dispose={null}>
          <group name="Scene">
            <group castShadow receiveShadow name="Armature" rotation={[0, 0, 0]} scale={0.01}>
              {/* <axesHelper args={[500]} /> */}
              <primitive object={nodes.mixamorigHips} />
              <skinnedMesh frustumCulled={false} castShadow receiveShadow name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} material={materials.Alpha_Joints_MAT} skeleton={nodes.Alpha_Joints.skeleton} />
              <skinnedMesh frustumCulled={false} castShadow receiveShadow name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} material={materials.Alpha_Body_MAT} skeleton={nodes.Alpha_Surface.skeleton} />
            </group>
          </group>
        </group>

      <PositionalAudio
        url="/sfx/pistol-shot.mp3"
        ref={shotSfxRef}
        distance={8}
        loop={false}
        position={[0, 1.5, 0]}
      />
      </RigidBody>

      {/* Muzzle Flash */}
      <mesh ref={muzzleFlashRef} visible={false}>
        <planeGeometry args={[0.5, 0.5]} />
        <meshBasicMaterial 
          map={createMuzzleFlashTexture}
          transparent
          opacity={0.9}
          blending={THREE.AdditiveBlending} // Additive blending for glowing effect
          depthWrite={false} // Don't write to depth buffer
          side={THREE.DoubleSide}
        />
      </mesh>

      {/* Muzzle Flash Light */}
      <pointLight
        ref={muzzleFlashLightRef}
        intensity={0}
        distance={MUZZLE_FLASH_LIGHT_DISTANCE}
        decay={2}
        color={0xffa500} // Orange/yellow color for gun flash
        visible={false}
      />

      <mesh ref={dotRef}>
        <sphereGeometry args={[0.1, 16, 16]} />
        <meshBasicMaterial visible color='gray' />
      </mesh>
    </group>
  )
}

useGLTF.preload('/models/player.glb')
